

## 信息——推荐的书
- 《江湖丛谈》
- 我有很多偶像，英国数学家乔治・布尔就是其中一个 —— 因为他就是个基本上只靠阅读自学成才的人。十八、九岁，就自学了微积分 —— 那是将近两百年前，没有 Google，没有 Wikipedia…… 然后他还自己创办了学校，给自己打工…… 从来没有上过大学，后来却被皇家学院聘请为该学院第一个数学教授。然后，人家发明的布尔代数，在百年之后引发了信息革命…… 


## python部分
1. 所有的代码，都可以在选中代码单元格（Code Cell）之后，按快捷键 ⇧ ⏎ 或 ^ ⏎ 执行，查看结果。
2. 在 Python 中每个函数都有返回值，即便你在定义一个函数的时候没有设定返回值，它也会加上默认的返回值 None……（请注意 None 的大小写！）
3. 针对数字进行计算的操作符有加减乘除商余幂：`+`、`-`、`*`、`/`、`//`、`%`、`**`。

其中 `+` 和 `-` 可以对单个值进行操作，`-3`；其它的操作符需要有两个值才能操作。

从优先级来看，这些操作符中：

> * 对两个值进行操作的 `+`、`-` 的优先级最低；
> * 稍高的是 `*`、`/`、`//`、`%`；
> * 更高的是对单个值进行操作的 `+`、`-`；
> * 优先级最高的是 `**`。

4. 每个变量或者常量，除了它们的值之外，同时还相当于有一个对应的布尔值。Part1 E2
5. 
6. 另外，以下几个链接先放在这里，未来你会返回来参考它们，还是不断地参考它们：

关于表达式：https://docs.python.org/3/reference/expressions.html
关于所有操作的优先级：https://docs.python.org/3/reference/expressions.html#operator-precedence
上一条链接不懂 BNF 的话根本读不懂：https://en.wikipedia.org/wiki/Backus-Naur_form
Python 的内建函数：https://docs.python.org/3/library/functions.html
Python 的标准数据类型：https://docs.python.org/3/library/stdtypes.html
7. 当字符串和数组被比较的时候，将从两个字符串各自的第一个字符开始逐个比较，“一旦决出胜负马上停止”：
8. range() 是个内建函数，它的文档是这样写的：
range(stop)
range(start, stop[, step])
// so range的负数函数是 range(0,-10,-1)
9. 换个角度去理解的话可能更清楚：pass 这个语句更多是给写程序的人用的。当你写程序的时候，你可以用 pass 占位，而后先写别的部分，过后再回来补充本来应该写在 pass 所在位置的那一段代码。
10. 关于字符串的内容总是很长 —— 就好像每本英语语法书中，关于动词的内容总是占全部内容的至少三分之二。这也没什么办法，因为处理字符串是计算机程序中最普遍的需求 —— 因为程序的主要功能就是完成人机交互，人们所用的就是字符串而不是二进制数字。
11. 转义符号 \ 的另外两个常用形式是和 t、n 连起来用，\t 代表制表符（就是用 TAB ⇥ 键敲出来的东西），\n 代表换行符（就是用 Enter ⏎ 敲出来的东西）。
12. list 口诀：左右空取到头，左要取，右不取。（意思是：右边的不取）用append()给列表增加元素，每次只能增加一个元素[我出错了]，添加多个参数用extend方法，该方法的参数为一个列表，将该指数所指定到的列表插入到原列表中
a = [0,0,0]
b = [1,2,3]
a.extend(b)
print a
1.  字典：这里需要强调的是，字典中的键具备唯一性，而值可重复。如果你不小心声明了两个以'小明'为键的【键值对】，后出现的【键值对】会覆盖前面的【键值对】
2.  
|      | 字典     | 列表                                 |
| ---- | ---------- | -------------------------------------- |
| 相同 | 都可以嵌套 | 都可以用赋值语句增加eg：score [1]='xx' |
| 不同 | 无序的  | 有序的，顺序不同，是不同的列表 |
https://tool.lu/tables

14. class 1、调用类属性： 实例名.属性名 2、调用类方法： 实例名.方法名().类方法中调用类内部属性或者是其他方法时，需要使用self来代表实例。
15. 面向对象编程，不考虑实现功能的步骤；而是考虑实现这个功能需要设计什么样的类，这个类中有哪些属性和方法。
16. 当我们作为用户想了解一个 Class 的 Interface，即，它的 Attributes 和 Methods 的时候，常用的有三种方式：

1. help(object)
2. dir(object)
3. object.__dict__

17. 所以，一个比较好的习惯是，如果传递进来的值是列表，那么在函数内部对其操作之前，先创建一个它的拷贝：


## VScode 快捷键
⇧⌘p 呼出 Command Palette 
使用快捷键 ⇧⌘x 呼出扩展面板。安装 anaconda 扩展
专业编辑器最重要的功能之一，就是能够在你输入的时候它帮你做到 “自动补全”，通常使用的快捷键是 TAB 键 ⇥。

## jupter lab 快捷键
选中上面的 Cell 之后按快捷键 shift + enter 
（按一下 ⎋，即 ESC，确保已经进入命令模式，⇧ L 可以切换是否显示代码行号）

## sublime snippest
command+B :执行代码

## 关于编程金句
“可编程”（Programable）—— 而所谓可编程的核心就是布尔运算及其相应的流程控制（Control Flow）
无论什么语言，不可能没有布尔运算，不可能没有流程控制，不可能没有函数，只要是高级语言，就都需要编译器…… 所以，掌握这些基本概念，是将来持续学习的基础
- 从结构上来看，一切的计算机程序，都由且只由两个最基本的成分构成：

> * **运算**（Evaluation）
> * **流程控制**（Control Flow）

没有流程控制的是计算器而已；有流程控制的才是可编程设备。

## 我的问题

1.
``` 
a_list = [1, 2, 3, 4, 5]  
b_list = [1, 2, 3, 5] 
c_list = ['ann', 'bob', 'cindy', 'dude', 'eric']
b_list in a_list 

why false?
A: in 不是包含关系，而是子集。是b的子集，之前是层级关系。
a_list>b_list 会出错因为，a和b是不同类型的数组不能比较
```

## 学习方法
1. 尽快开始整理归纳总结。自学能力强的人有个特点，就是不怕麻烦。小时候经常听到母亲念叨，“怕麻烦！那还活着干嘛啊？活着多麻烦啊！” —— 深刻。
2. > **第一查询对象只能是官方文档**。
所以，当我用 Google 查询的时候，经常使用这样的格式：
> `<queries> site:python.org`有时甚至会指定在哪个目录里搜索：
    > `bytes site:python.org/3/library`，你试试这个连接：[bytes site:python.org/3/library](https://www.google.com/search?q=byte+site%3Apython.org%2F3%2Flibrary)
3. 一切 “主要靠时间” 的活动都一样，都需要在从事之前认真做 “心理建设”。通常情况下，读一本教程，上个学习班，就 “会” 了 —— 几乎肯定是错觉或者幻觉。

> - 首先要明白，这肯定是个比 “天真的想象” 要长得多的过程。
> - 其次要明白，并且要越来越自然地明白，哪儿哪儿都需要很多重复。读，要读很多遍；练，要练很多遍；做，要做很多遍……

4. **预算观念**非常重要 —— 这个观念的存在与否，成熟与否，基本上决定一个人未来的盈利能力。

大多数人对此不仅不成熟，甚至干脆没有预算观念！—— 这也是为什么绝大多数人不适合创业的最根本原因。

不夸张地讲，未来的你只需要恪守一个原则，就很可能会因此超越 99% 的人：

> 绝对不做预算不够的事情。

5. 这事折磨了我好多年…… 直到后来我当了老师，每年面前流过几万名学生之后，我才 “羞耻” 地反应过来：

> * 我花在刻意练习上的时间**太少**了；
> * 并且，也没有**刻意思考**哪些地方我应该去刻意练习。

而那些看起来 “一出手就是高手” 的人，则恰恰相反，他们不仅花很多时间刻意练习，还总是刻意思考在哪些地方尤其要刻意练习 —— 就是这一点差别造成了那么大的差距。

6. 这事折磨了我好多年…… 直到后来我当了老师，每年面前流过几万名学生之后，我才 “羞耻” 地反应过来：

> * 我花在刻意练习上的时间**太少**了；
> * 并且，也没有**刻意思考**哪些地方我应该去刻意练习。

而那些看起来 “一出手就是高手” 的人，则恰恰相反，他们不仅花很多时间刻意练习，还总是刻意思考在哪些地方尤其要刻意练习 —— 就是这一点差别造成了那么大的差距。


7. “写作” 部分一上来就从函数入手也的确是 “更正确” 的，因为结构化编程的核心就是拆分任务，把任务拆分到不能再拆分为止.